//Task1
console.log('Task №1');

function makeSomeCoolStaff(){
  b++;
  console.log(`1.1: ${a}`);    // 1. a = undefind (т.к. на момент ініціалізації функції змінна "а" ще не існувала. Правду кажучи не знаю, чому.)
  console.log(`1.2: ${b}`);    // 2. b = NAN (т.к. на момент логу вона не була об'явлена, але вже була інкримінована)
  console.log(`1.3: ${c}`);    // 3. c = 8 (т.к. const, що була об'явлена встроі 22 має блочну область видимості і була об'явлена раніше ніж була об'явлена функція(строка 27).)
  if (!a){
    var a = 5;
    var b = 4;
    console.log(`1.4: ${a}`);  // 4. a = 5 (т.к. була проініціалізована для блока if в строці 10.)
    console.log(`1.5: ${b}`);  // 5. b = 4 (т.к. була проініціалізована для блока if в строці 4.)
    console.log(`1.6: ${c}`);  // 6. с = 8 (т.к. const, що була об'явлена встроі 22 має блочну область видимості і була об'явлена раніше ніж була об'явлена функція(строка 27).)
  }
  console.log(`1.7: ${a}`);    // 7. a = 5 (т.к. var визначає локальні змінні функції тому змінна "а", яка об'явлена в строці 10 перебиває ту, що у нас в 21 строці)
  console.log(`1.8: ${b}`);    // 8. b = 4 (т.к. var визначає локальні змінні функції тому змінна "b", яка об'явлена в строці 11 перебиває ту, що у нас в 5 строці)
  console.log(`1.9: ${c}`);    // 9. c = 8 (т.к. const, що була об'явлена встроі 22 має блочну область видимості і була об'явлена раніше ніж була об'явлена функція(строка 27).)
}

let a = 1;
const c = 8;

console.log(`1.10: ${a}`);     // 10. a = 1 (т.к її тільки об`явили у 22 строці.)
console.log(`1.11: ${b}`);     // 11. b = undefind (т.к. вона ще не буда об'явлена.)
console.log(`1.12: ${c}`);     // 12. c = 8 (т.к. вона була опроініціалізована в строці 19.)
makeSomeCoolStaff();
console.log(`1.13: ${a}`);     // 13. a = 1 (т.к. a, що об'явлена в 21 строці має блочну область видимості і скоуп бачить її єдину.)
console.log(`1.14: ${b}`);     // 14. b = undefind (т.к. на момент об'яви змінна b не існує.)
console.log(`1.15: ${c}`);     // 15. c = 8 (т.к. a, що об'явлена в 22 строці має блочну область видимості і скоуп бачить її єдину.)

var b = 2;
a = 7;

console.log(`1.16: ${a}`);     // 16. a = 7 (т.к. змінна а була перезатерта у строці 33.)
console.log(`1.17: ${b}`);     // 17. b = 2 (т.к. змінна була об'явлена в строці 32.)
console.log(`1.18: ${c}`);     // 18. c = 8 (т.к. a, що об'явлена в 22 строці має блочну область видимості і скоуп бачить її єдину.)

//Task 2
//-------------------------------------------------------------
console.log('Task №2');

console.log(`2.1: ${1 + 1}`);     // = 2 (т.к. у нас складаються два числа типу number)
console.log(`2.2: ${'1' + 1}`);   // = 11 (т.к. перша '1' у нас строка, то оператор "+" сприймається, як конкатенація строк)
console.log(`2.3: ${1 + [2]}`);   // = 12 (т.к. масив "[2]", розкладається через метод toString у строку, оператор "+" конкатенує строки)
console.log(`2.4: ${1 + {}}`);    // = 1[object, object] (т.к. об'єкт розкладається у строку '[object, object]', а потім через оператор "+" конкатенується із 1)
console.log(`2.5: ${2 - {}}`);    // = NAN (т.к. об'єкт розкладається у строку '[object, object]', а потім через оператор "-" проводить математичну операцію. Оскільки '[object, object]' – строка, то отримуємо NAN.)
console.log(`2.6: ${+'a'}`);      // = NAN (через оператор "+" у нас строка намагається привестися до числа. Т.к. "а" – не число, то отримуємо NAN.)
console.log(`2.7: ${+''}`);       // = 0 (через оператор "+" у нас строка намагається привестися до числа. Т.к. маємо пусту строку, то отримуємо нуль) 
console.log(`2.8: ${+'-1'}`);     // = -1 (через оператор "+" у нас строка намагається привестися до числа. Т.к. "-1" – число, то отримуємо -1.)
console.log(`2.9: ${+{}}`);       // = NAN (т.к. об'єкт розкладається на '[object, object]', а потім через оператор "+" у нас строка намагається привестися до числа і ми отримуємо NAN.)
console.log(`2.10: ${1 + 'a'}`);  // = 1a (т.к. перша 1 у нас число, то оператор "+" конкатенує у нас число з строкою і отримаємо '1а')
console.log(`2.11: ${1 + {}}`);   // = 1[object, object] (т.к. об'єкт розкладається у строку '[object, object]', а потім через оператор "+" конкатенується із 1)
console.log(`2.12: ${[] + []}`);  // = '' (тому що обидва масиви привелися до строк і сконкатенувалися в  1 пусту строку – '')
console.log(`2.13: ${1 - 'a'}`);  // = NAN (т.к. перша 1 у нас число, то оператор "-" проводить логічну опирацію із строкою 'а'. Оскільки 'а' – не число, то маємо,що маємо – NAN)
console.log(`2.14: ${1 - {}}`);   // = NAN (т.к. об'єкт розкладається у строку '[object, object]', а потім через оператор "-" проводить логічну операцію з одиницею, після чого отримуємо NAN)
console.log(`2.15: ${[] - []}`);  // = 0 (тому що обидва масиви привелися до строк і ми маємо логічний оператор "-" то пусті строки віднялися і ми отримали 0)