let a = 2;
if (false) {
var b = 3;
}

console.log('1: ' + a); // 1. a = 2(т.к була проініціалізована в строці 1)
console.log('2: ' + b); // 2. b = undefind(т.к умова стоці 2 не виконана)
console. log('3: ' + c); // 3. c = undefind (тому що "мені здається" вона ініціалізується після консол логу. При компіляції движок js спочатку ініціалізую var, потім function, а потім починає запускати код з початку до кінця "згори до низу" й на момент компіляції змінна "с" не існує)

makeSomeCoolStaff();

const c = 4;

function makeSomeCoolStaff(){
  let b = 5;
  console. log('4: ' + a); // 4. a = 2 (т.к. в функції 'makeSomeCoolStaff' змінної "а" не існує, компілятор починає виходити за її межі й знову почне її шукати "згори до низу" у зовнішній області видимості, тому змінна а=2)
 
  console. log('5: ' + b); // 5. b = 5 (т.к. змінна "b" була об`явлена всередині функції й компілятор побачив її першою у скоупі, що створила функція "makeSomeCoolStaff")
  console.log('6: ' + c); // 6. с = undefind (т.к в функції 'makeSomeCoolStaff' об'явлена після ініціалізації змінної "с")

  if (true) {
    var c = 6;
    const a = 7;
    b = 8;
    console.log('7: ' + a); // 7. a = 7 (т.к "if" створює нову область видимості в якій змінна "а" об'явлена, як константа яка дорівнює 7) 
    console. log('8: ' + b); // 8. b = 8 (т.к була змінена в блочній області видимості "if")
    console.log('9: ' + c); // 9. c = 6 (т.к. "if" створює нову область видимості в якій змінна "с" об'явлена, як змінна, що дорівнює 6)
  }
  
  console.log('10: ' + a); // 10. a = 2 (т.к. в функції 'makeSomeCoolStaff' змінної "а" не існує, компілятор починає виходити за її межі й знову почне її шукати "згори до низу" у зовнішній області видимості, тому змінна а=2 + він її не бачить об'явленною у скоупі, що створює "if")
  console. log('11: ' + b); // 11. b = 5 (т.к. змінна "b" була об`явлена всередині функції й компілятор побачив її першою у скоупі, що створила функція "makeSomeCoolStaff" + він її не бачить об'явленною у скоупі, що створює "if")
  console.log('12: ' + c); // 12. c = 6 (т.к. змінна "c" була об'явлена в скоупі, що створив "if". Він її побачив, тому що "var" може обмежуватися функцією чи бути глобальним, для змінних, оголошених поза функції.)
}

console.log('13: ' + a); // 13. a = 2 (т.к була об'явлена в 1 строці й не була ніяк перезаписана)
console.log('14: ' + b); // 14. b = undefind(т.к умова стоці 2 не виконана)
console.log('15: ' + c); // 15. с = 4 (т.к. була об'явлена в глобального скоупі під видом константи + тому вона не могла бути перезатертою)


//------------------------------------------------------------------------------------------------------------------------------------------


typeof ('Success' * 7); // number
typeof (true + false); // 1
typeof (12 / '6'); // nubmer
typeof ('number' + 15 + 3); // string (т.к. перший операнд у нас строка, а потім іде оператор "+", то js вважає, що ми хочемо сконкатенувати строки,тобто до сторки 'number' + 15, а потім до 'number15' + 3, і отримуємо 'number153'.)
typeof (15 + 3 + 'number'); // string (т.к. спочатку у нас проходить операція 15 + 3, а потім 18 + 'number', і проходить приведення до строки.)
typeof ([1] > null); // boolean (спочатку у нас приводиться неявне перетворення масива у строку і null до числа. Після першої ітерації ми матимемо строку строку '1', логічний оператор ">" і число 0. Потім у нас строка приводиться до числа і починають порівнюватися 1 і 0. Тому ми і отримуємо логічну операцію.)
typeof ('foo' + +'bar'); // string (т.к. 'bar' починає перетворюватисяна число після чого ми отримаємо 'NAN', а потім відбудеться конкатенація і ми отримаємо "fooNAN")
typeof ('true' == true); // boolean (у нас є логічний оператор "==", що порівнює строку й "true" з логічним значенням true, тому операція булева)
typeof (false == 'false'); // boolean (у нас є логічний оператор "==", що порівнює логічне значенням false зі строкою "false", тому операція булева)
typeof (null == ''); // boolean (у нас є логічний оператор "==", що порівнює null із строкою, тому операція булева)
typeof (!!'false' == !!'true'); // boolean (у нас є логічний оператор "==", що порівнює логічне "!!"(ні) зі строкою "true" і "false", тому операція булева)
typeof (['x'] == 'x'); // boolean (у нас є логічний оператор "==", що порівнює масив зі строкою, що потім приведеться до строки й строку, тому операція булева)
typeof !!{}; // boolean (у нас є логічний оператор "!!", що приводить до об'єкт до логічного типу, тому операція булева)
typeof ![]; // boolean (у нас є логічний оператор "!", що приводить до масив до логічного типу, тому операція булева)
typeof ([] + null + 1); // string (тому що масив приводиться до типу string, оператор "+" робить два рази конкатенацію строк, післячого ми отримаємо "null1")
typeof ([1, 2, 3] == [1, 2, 3]); // boolean (у нас є логічний оператор "==", що порівнює два масиви, що преобразуються у строки, тому операція булева)
typeof ({} + [] + {} + [1]); // string (перший операнд {} сприймається як блок коду,тому ми його пропускаємо, +[] –  преобразується в строку)
typeof (!+[] + [] + ![]); // string (перший, як і останній масив приводиться до типів boolean, а той, який всередині приводиться до строки, потім "true" від першого масиву і "false" від останнього конкатенуються із строю, яка всередині і отримуємо строку "truefalse") 
typeof (new Date(0) - 0); // number (через  оператор "-" об'єкт Date конвертується у число і від нього віднімає 0)
typeof (new Date(0) + 0); // string (через  оператор "+" об'єкт Date конвертується по-замовчуванню в строку і до нього конкатенує 0)